/*
* SPDX-License-Identifier: GPLv3
 *
 * Copyright (c) 2025 Richard A. Sch√§fer
 *
 * This file is part of genogrove and is licensed under the terms of the GPLv3 license.
 * See the LICENSE file in the root of the repository for more information.
 */
#ifndef GENOGROVE_IO_BEDREADER_HPP
#define GENOGROVE_IO_BEDREADER_HPP

// standard
#include <string>
#include <filesystem>
#include <optional>
#include <vector>

// genogrove
#include <genogrove/io/file_reader.hpp>
#include <genogrove/data_type/all.hpp>

// htslib
#include <htslib/bgzf.h>

namespace gdt = genogrove::data_type;

namespace genogrove::io {
    struct rgb_color {
        uint8_t red;
        uint8_t green;
        uint8_t blue;

        rgb_color() = default;
        rgb_color(uint8_t red_val, uint8_t green_val, uint8_t blue_val)
            : red(red_val), green(green_val), blue(blue_val) {}
    };

    struct thick_info {
        uint64_t start; // needs to hold 2^64-1
        uint64_t end;

        thick_info() = default;
        thick_info(uint64_t start_val, uint64_t end_val) : start(start_val), end(end_val) {}
    };

    struct block_info {
        int count;
        std::vector<size_t> sizes;
        std::vector<size_t> starts;

        block_info() = default;
        block_info(int count, std::vector<size_t> sizes, std::vector<size_t> starts)
            : count(count), sizes(std::move(sizes)), starts(std::move(starts)) {}
    };

    /**
     * @class bed_entry
     * @brief Represents a single entry in a BED (Browser Extensible Data) file.
     *
     * The bed_entry class is designed to encapsulate the data associated with
     * a single genomic interval in a BED file. BED files are commonly used to
     * describe genomic regions, such as those generated by alignment or
     * variant-calling processes in bioinformatics.
     *
     * This class provides a means to store and process information about
     * chromosomal intervals with optional annotation fields.
     *
     * See https://samtools.github.io/hts-specs/BEDv1.pdf
     */
    struct bed_entry {
        std::string chrom;
        gdt::interval interval;

        // optional BED fields (for BED4+)
        std::optional<std::string> name;
        std::optional<int> score;
        std::optional<char> strand;

        // optional BED fields (for BED6+)
        std::optional<thick_info> thickness;
        std::optional<rgb_color> item_rgb;

        // BED12 block information
        std::optional<block_info> blocks;

        bed_entry() = default;
        bed_entry(std::string chrom, gdt::interval interval) : chrom(chrom), interval(interval) {}
    };

    class bed_reader : public file_reader<bed_entry> {
    public:
        bed_reader(const std::filesystem::path& path);

        // Non-copyable (owns raw BGZF* resource)
        bed_reader(const bed_reader&) = delete;
        bed_reader& operator=(const bed_reader&) = delete;

        // Movable
        bed_reader(bed_reader&& other) noexcept
            : bgzf_file(other.bgzf_file), line_num(other.line_num),
              error_message(std::move(other.error_message)) {
            other.bgzf_file = nullptr;
        }
        bed_reader& operator=(bed_reader&& other) noexcept {
            if (this != &other) {
                if (bgzf_file) bgzf_close(bgzf_file);
                bgzf_file = other.bgzf_file;
                line_num = other.line_num;
                error_message = std::move(other.error_message);
                other.bgzf_file = nullptr;
            }
            return *this;
        }

        bool read_next(bed_entry& entry) override;
        bool has_next() override;
        std::string get_error_message() override;
        size_t get_current_line() override;
        ~bed_reader() override;

    private:
        BGZF* bgzf_file;
        size_t line_num;
        std::string error_message;

        // Helper functions for parsing BED fields
        bool parse_score(bed_entry& entry, const std::string& score_str);
        bool parse_strand(bed_entry& entry, const std::string& strand_str);
        bool parse_thickness(bed_entry& entry, const std::string& thick_start_str,
                           const std::string& thick_end_str, size_t start_num, size_t end_num);
        bool parse_rgb(bed_entry& entry, const std::string& item_rgb_str);
        bool parse_blocks(bed_entry& entry, const std::string& block_count_str,
                        const std::string& block_sizes_str, const std::string& block_starts_str,
                        size_t start_num, size_t end_num);
    };

}

#endif //GENOGROVE_IO_BEDREADER_HPP
